"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var express=_interopDefault(require("express")),http=_interopDefault(require("http")),https=_interopDefault(require("https")),Databases=require("itee-database"),iteeValidators=require("itee-validators"),path=_interopDefault(require("path"));class TBackendManager{constructor(e){this.rootPath=e.rootPath,this.applications=express(),this.router=express.Router,this.databases=new Map,this.servers=new Map,this._initApplications(e.applications),this._initDatabases(e.databases),this._initServers(e.servers)}get rootPath(){return this._rootPath}set rootPath(e){if(iteeValidators.isNull(e))throw new TypeError("Root path cannot be null ! Expect a non empty string.");if(iteeValidators.isUndefined(e))throw new TypeError("Root path cannot be undefined ! Expect a non empty string.");if(iteeValidators.isNotString(e))throw new TypeError(`Root path cannot be an instance of ${e.constructor.name} ! Expect a non empty string.`);if(iteeValidators.isEmptyString(e))throw new TypeError("Root path cannot be empty ! Expect a non empty string.");if(iteeValidators.isBlankString(e))throw new TypeError("Root path cannot contain only whitespace ! Expect a non empty string.");this._rootPath=e}setRootPath(e){return this.rootPath=e,this}_initApplications(e){e.case_sensitive_routing&&this.applications.set("case sensitive routing",e.case_sensitive_routing),e.env&&this.applications.set("env",e.env),e.etag&&this.applications.set("etag",e.etag),e.jsonp_callback_name&&this.applications.set("jsonp callback name",e.jsonp_callback_name),e.jsonp_escape&&this.applications.set("json escape",e.jsonp_escape),e.jsonp_replacer&&this.applications.set("json replacer",e.jsonp_replacer),e.jsonp_spaces&&this.applications.set("json spaces",e.jsonp_spaces),e.query_parser&&this.applications.set("query parser",e.query_parser),e.strict_routing&&this.applications.set("strict routing",e.strict_routing),e.subdomain_offset&&this.applications.set("subdomain offset",e.subdomain_offset),e.trust_proxy&&this.applications.set("trust proxy",e.trust_proxy),e.views&&this.applications.set("views",e.views),e.view_cache&&this.applications.set("view cache",e.view_cache),e.view_engine&&this.applications.set("view engine",e.view_engine),e.x_powered_by&&this.applications.set("x-powered-by",e.x_powered_by),this._initMiddlewares(e.middlewares),this._initRouters(e.routers)}_initMiddlewares(e){for(let t in e){if(!Object.prototype.hasOwnProperty.call(e,t))continue;const o=e[t];if(iteeValidators.isNotArray(o))throw new TypeError(`Invalid middlware configuration, expect an array of argument to spread to middleware module, got ${o.constructor.name}`);try{this.applications.use(require(t)(...o)),console.log(`Use ${t} middleware from node_modules`)}catch(e){if(!e.code||"MODULE_NOT_FOUND"!==e.code){console.error(`The middleware "${t}" seems to encounter internal error.`),console.error(e);continue}this._initLocalMiddleware(t,o)}}}_initLocalMiddleware(e,t){try{const o=path.join(this.rootPath,"middlewares",e);this.applications.use(require(o)(...t)),console.log(`Use ${e} middleware from local folder`)}catch(t){t instanceof TypeError&&"Found non-callable @@iterator"===t.message?(console.error(`The middleware "${e}" seems to encounter internal error !`),console.error(t)):(console.error(`Unable to register the middleware ${e} the package or local file doesn't seem to exist ! Skip it.`),console.error(t))}}_initRouters(e){for(let t in e){if(!Object.prototype.hasOwnProperty.call(e,t))continue;const o=e[t],s=o.baseRoute,r=o.options;try{const e=require(t);this.applications.use(s,iteeValidators.isFunction(e)?e(...r):e),console.log(`Use ${t} router from node_modules over base route: ${s}`)}catch(e){if(!e.code||"MODULE_NOT_FOUND"!==e.code){console.error(`The router "${t}" seems to encounter internal error.`),console.error(e);continue}this._initLocalRouter(t,s,r)}}}_initLocalRouter(e,t,o){try{const s=path.join(this.rootPath,"routers",e),r=require(s);this.applications.use(t,iteeValidators.isFunction(r)?r(...o):r),console.log(`Use ${e} router from local folder over base route: ${t}`)}catch(t){t instanceof TypeError&&"Found non-callable @@iterator"===t.message?(console.error(`The router "${e}" seems to encounter internal error !`),console.error(t)):(console.error(`Unable to register the router ${e} the package or local file doesn't seem to exist ! Skip it.`),console.error(t))}}_initDatabases(e){for(let t=0,o=e.length;t<o;t++){const o=e[t],s=o.type,r=`${o.name?o.name:"Database_"+t}`;try{const e=new Databases[s](this.applications,this.router,o.plugins,o).connect();this.databases.set(r,e)}catch(e){console.error(`Unable to create database of type ${s} due to ${e.name}`),console.error(e.message),console.error(e.stack)}}}_initServers(e){const t=iteeValidators.isArray(e)?e:[e];for(let e=0,o=t.length;e<o;e++){let o=t[e],s=null;if("https"===o.type){const e={pfx:o.pfx,passphrase:o.passphrase};s=https.createServer(e,this.applications)}else s=http.createServer(this.applications);s.name=o.name||`${o.name?o.name:"Server_"+e}`,s.maxHeadersCount=o.max_headers_count,s.timeout=o.timeout,s.type=o.type,s.host=o.host,s.port=o.port,s.env=o.env,s.listen(o.port,o.host,()=>{console.log(`${s.name} start listening on ${s.type}://${s.host}:${s.port} at ${new Date} under ${s.env} environment.`)}),this.servers.set(s.name,s)}}databaseOn(e,t,o){}serverOn(e,t){for(const[o,s]of this.servers)s.on(e,t)}start(){}stop(e){const t=this.servers.size,o=this.databases.size;let s=0,r=0;if(0!==t||0!==o)for(const[i,a]of this.servers)a.close(()=>{if(s++,console.log(`Shutdown ${i} listening on ${a.type}://${a.host}:${a.port} at ${new Date}.`),!(s<t))if(0!==o)for(const[t,s]in this.databases)s.close(()=>{r++,console.log(`Closeconnection to ${t}.`),r<o||e()});else e()});else e()}closeServers(){}}exports.TBackendManager=TBackendManager;
//# sourceMappingURL=itee-server.cjs.min.js.map
